#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use FindBin;
use lib $FindBin::Bin;
use UneceParser;

my $s = UneceParser::load_segments_file('edsd/EDSD.99A');
#print Dumper($s);
print make_c_defs_segments($s);

#my $c = UneceParser::load_composites_file('edcd/EDCD.99A');
#print Dumper($c);

#my $e = UneceParser::load_elements_file('eded/EDED.99A');
#print Dumper($e);

#my $c1 = UneceParser::load_codes_file('uncl/UNCL.99A');
#print Dumper($c1);

#my $c2 = UneceParser::load_codes_file('unsl/UNSL.99A');
#print Dumper($c2);

sub make_c_defs_segments
{
	my($s) = @_;
	my $struct_name = 'edi_segment';
	my $var_name = 'segments';
	my $structs = "static struct ${struct_name} ${var_name}[] = {\n";
	my $els = '';
	foreach my $seg(sort keys %$s) {
		my $title1 = $s->{$seg}{title};
		my $title2 = lc $title1; $title2 =~ s#\W+#_#sg;
		my $function = $s->{$seg}{function};
		my $children = "seg_${seg}_children";
		$structs .= qq#\t{ "$seg", "$title1", "$title2", "$function", $children },\n#;
		$els .= qq#static const char * ${children}[] = {#;
		foreach my $c(@{ $s->{$seg}{elements} }) {
			$els .= qq# "$c",#;
		}
		$els .= qq# NULL };\n#;
	}
	$structs .= "};\n";
	return join("\n\n", "/* Autogenerated file */", "#include \"edistruct.h\"", $els, $structs, make_find_name_function($struct_name, $var_name));
}

sub make_find_name_function
{
	my($struct, $var) = @_;
return << "***";
const struct ${struct} * find_${struct}(const char * name)
{
	size_t begin = 0;
	size_t end = sizeof(${var})/sizeof(${var}[0]);
	for(;;) {
		size_t cur = (begin + end) / 2;
		int cmp = strcmp(name, ${var}[cur].name);
		if(cmp == 0) return & ${var}[cur];
		if(cmp < 0) end = cur; else begin = cur + 1;
		if(end - begin < 1) return NULL;
	}
}
***
}

