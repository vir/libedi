#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use FindBin;
use lib $FindBin::Bin;
use UneceParser;

my $z = {};
UneceParser::load_codes_file('uncl/UNCL.99A', $z);
UneceParser::load_codes_file('unsl/UNSL.99A', $z);
print Dumper($z);

my $s = {};
my $c = {};
my $e = {};
UneceParser::load_segments_file('edsd/EDSD.99A', $s);
UneceParser::load_composites_file('edcd/EDCD.99A', $c);
UneceParser::load_elements_file('eded/EDED.99A', $e);
UneceParser::load_annexb('part4/D422.TXT', $s, $c, $e);
#print "SEGMENTS: ".Dumper($s);

open F, ">", "segs.c" or die;
print F make_c_defs_segments($s, 'segment');
close F or die;

open F, ">", "comps.c" or die;
print F make_c_defs_segments($c, 'composite');
close F or die;

open F, ">", "elems.c" or die;
print F make_c_defs_elements($e, 'element', $z);
close F or die;

open F, ">", "coded.c" or die;
print F make_c_defs_coded($z);
close F or die;


sub make_c_defs_segments
{
	my($s, $namepart) = @_;
	my $struct_name = "edistruct_${namepart}";
	my $var_name = "${namepart}s";
	my $structs = "static struct ${struct_name} ${var_name}[] = {\n";
	my $els = '';
	foreach my $seg(sort keys %$s) {
		my $title1 = $s->{$seg}{title};
		my $title2 = make_title2($title1);
		my $function = $s->{$seg}{function};
		my $children = "${namepart}_${seg}_children";
		$structs .= qq#\t{ "$seg", "$title1", "$title2", "$function", $children },\n#;
		$els .= qq#static const char * ${children}[] = {#;
		foreach my $c(@{ $s->{$seg}{elements} }) {
			$els .= qq# "$c",#;
		}
		$els .= qq# NULL };\n#;
	}
	$structs .= "};\n";
	return join("\n\n", "/* Autogenerated file */", "#include \"edistruct.h\"\n#include <string.h>", $els, $structs, make_find_name_function($struct_name, $var_name));
}

sub make_c_defs_elements
{
	my($s, $namepart, $codes) = @_;
	my $struct_name = "edistruct_${namepart}";
	my $var_name = "${namepart}s";
	my $structs = "static struct ${struct_name} ${var_name}[] = {\n";
	foreach my $el(sort keys %$s) {
		my $title1 = $s->{$el}{title};
		my $title2 = make_title2($title1);
		my $function = $s->{$el}{function};
		my $format = $s->{$el}{format};
		my $is_coded = $codes->{$el} ? 1 : 0;
		$structs .= qq#\t{ "$el", "$title1", "$title2", "$function", "$format", $is_coded },\n#;
	}
	$structs .= "};\n";
	return join("\n\n",
		"/* Autogenerated file */",
		"#include \"edistruct.h\"\n#include <string.h>",
		$structs,
		make_find_name_function($struct_name, $var_name));
}

sub make_title2
{
	my($title1) = @_;
	my $title2 = lc $title1;
	$title2 =~ s/\'//sg;
	$title2 =~ s/^\W+//s;
	$title2 =~ s/\W+$//s;
	$title2 =~ s/,\s+coded\W*$//;
	$title2 =~ s#\W+#_#sg;
	return $title2;
}

sub make_find_name_function
{
	my($struct, $var) = @_;
return << "***";
const struct ${struct} * find_${struct}(const char * name)
{
	size_t begin = 0;
	size_t end = sizeof(${var})/sizeof(${var}[0]);
	for(;;) {
		size_t cur = (begin + end) / 2;
		int cmp = strcmp(name, ${var}[cur].name);
		if(cmp == 0) return & ${var}[cur];
		if(cmp < 0) end = cur; else begin = cur + 1;
		if(end - begin < 1) return NULL;
	}
}
***
}

sub make_c_defs_coded
{
	my($z) = @_;
	my $vals = '';
	my $structs = "static struct coded_values coded_values_table[] = {\n";
	foreach my $el(sort keys %$z) {
		my $x = $z->{$el}{map};
		my $vals_name = "vals_$el";
		$vals .= "static edistruct_coded_t ${vals_name}[] = {\n";
		foreach my $val(sort keys %$x) {
			my($title1, $function) = @{ $x->{$val} };
			my $title2 = make_title2($title1);
			$function = escape_c($function);
			$title1 = escape_c($title1);
			$vals .= qq#\t{ "$val", "$title1", "$title2", "$function" },\n#;
		}
		$vals .= "};\n\n";
		my $vals_size = scalar keys %$x;
		$structs .= qq#\t{ "$el", $vals_name, $vals_size },\n#;
	}
	$structs .= "};\n";
	return join("\n\n",
		"/* Autogenerated file */",
		"#include \"edistruct.h\"\n#include <string.h>",
		"struct coded_values { const char * el; const edistruct_coded_t * vals; size_t nvals; };\n",
		$vals,
		$structs,
		make_find_coded_value_function()
	);
}

sub escape_c
{
	local($_) = @_;
	s#([\'\"\\])#\\$1#sg;
	return $_;
}

sub make_find_coded_value_function
{
	return << '***';
static const struct edistruct_coded * find_actual_value(const struct coded_values * tab, const char * name)
{
	size_t begin = 0;
	size_t end = tab->nvals;
	for(;;) {
		size_t cur = (begin + end) / 2;
		int cmp = strcmp(name, tab->vals[cur].name);
		if(cmp == 0) return &tab->vals[cur];
		if(cmp < 0) end = cur; else begin = cur + 1;
		if(end - begin < 1) return NULL;
	}
}

const struct edistruct_coded * find_coded_value(const char * elem, const char * name)
{
	size_t begin = 0;
	size_t end = sizeof(coded_values_table)/sizeof(coded_values_table[0]);
	for(;;) {
		size_t cur = (begin + end) / 2;
		int cmp = strcmp(elem, coded_values_table[cur].el);
		if(cmp == 0) return find_actual_value(&coded_values_table[cur], name);
		if(cmp < 0) end = cur; else begin = cur + 1;
		if(end - begin < 1) return NULL;
	}
}
***
}
